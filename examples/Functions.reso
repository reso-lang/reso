# Simple function with no parameters and no return value (unit type)
def greet():
    println("Hello, Reso!")

# Function with parameters and return type
def add(a: i32, b: i32) -> i32:
    return a + b

# Function with explicit return type annotation
def subtract(x: i32, y: i32) -> i32:
    var result: i32 = x - y
    return result

# Function that returns a boolean
def isEven(number: i32) -> bool:
    return (number rem 2) == 0

# Function with multiple parameters of different types
def formatPersonInfo(name: String, age: i32, height: f64) -> String:
    return (name.append(" is ")
        .append(age.toString())
        .append(" years old and ")
        .append(height.toString())
        .append("m tall"))

# Function that performs calculations
def calculateArea(length: f64, width: f64) -> f64:
    return length * width

# Function that returns early based on condition
def findMax(a: i32, b: i32, c: i32) -> i32:
    if a >= b and a >= c:
        return a
    
    if b >= c:
        return b
    
    return c

# Function that returns the unit type
def printNumbers(count: i32) -> ():
    var i: i32 = 1
    while i <= count:
        println("Number: ".append(i.toString()))
        i += 1
    return ()

# Function that uses other functions
def calculateAndPrint(x: i32, y: i32):
    var sum = add(x, y)
    var difference = subtract(x, y)
    
    println("Sum: ".append(sum.toString()))
    println("Difference: ".append(difference.toString()))
    
    if isEven(sum):
        println("Sum is even")
    else:
        println("Sum is odd")

# Function with complex logic
def classifyNumber(num: i32) -> String:
    if num == 0:
        return "zero"
    else if num > 0:
        if isEven(num):
            return "positive even"
        else:
            return "positive odd"
    else:
        if isEven(num):
            return "negative even"
        else:
            return "negative odd"

# Recursive function
def fibonacci(n: i32) -> i32:
    if n <= 1:
        return n

    return fibonacci(n - 1) + fibonacci(n - 2)

# Main function - program entry point
def main() -> i32:
    println("=== Functions in Reso ===")
    
    # Calling functions with no parameters
    println("=== Simple Function Calls ===")
    greet()
    
    # Calling functions with parameters
    println("=== Functions with Parameters ===")
    var sum = add(15, 25)
    var diff = subtract(50, 20)
    
    println("15 + 25 = ".append(sum.toString()))
    println("50 - 20 = ".append(diff.toString()))
    
    # Boolean returning functions
    println("=== Boolean Functions ===")
    var num1: i32 = 42
    var num2: i32 = 17
    
    println(num1.toString().append(" is even: ").
        append(isEven(num1).toString()))
    println(num2.toString().append(" is even: ")
        .append(isEven(num2).toString()))
    
    # String returning functions
    println("=== String Functions ===")
    var info = formatPersonInfo("Alice", 30, 1.65)
    println(info)
    
    # Mathematical functions
    println("=== Mathematical Functions ===")
    var area = calculateArea(5.0, 3.5)
    println("Rectangle area (5.0 x 3.5): ".append(area.toString()))
    
    # Functions with multiple return paths
    println("=== Multiple Return Paths ===")
    var maxVal = findMax(10, 25, 15)
    println("Max of 10, 25, 15: ".append(maxVal.toString()))
    
    # Classification function
    println("=== Number Classification ===")
    var numbers: Vector<i32> = Vector()
    numbers.add(0)
    numbers.add(7)
    numbers.add(-4)
    numbers.add(12)
    
    var i: usize = 0
    while i < numbers/size.get():
        var num = numbers[i].get()
        var classification = classifyNumber(num)
        println(num.toString().append(" is ")
            .append(classification))
        i += 1

    # Function composition
    println("=== Function Composition ===")
    calculateAndPrint(20, 8)
    
    # Small Fibonacci demonstration (be careful with larger values)
    println("=== Fibonacci ===")
    var fibNums: Vector<i32> = Vector()
    fibNums.add(0)
    fibNums.add(1)
    fibNums.add(2)
    fibNums.add(3)
    fibNums.add(4)
    fibNums.add(5)
    
    i = 0
    while i < fibNums/size.get():
        var n = fibNums[i].get()
        var fibN = fibonacci(n)
        println("Fibonacci(".append(n.toString())
            .append(") = ")
            .append(fibN.toString()))
        i += 1