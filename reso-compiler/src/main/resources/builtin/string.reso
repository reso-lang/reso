resource String{
    const data: Vector<u8>
}:
    path:
        pub def append(other: String) -> String:
            if other == null:
                return this  # Cannot append null

            if other.is_empty():
                return this  # No change needed when appending empty string

            if this.is_empty():
                return other  # Just return the other string if this is empty

            # Calculate new size
            const this_size = this.data/size.get() - 1  # Exclude null terminator
            const other_size = other.data/size.get() - 1  # Exclude null terminator

            # Create result vector
            var result: Vector<u8> = Vector()

            # Copy bytes from this string
            var i: usize = 0
            while i < this_size:
                result.add(this.data[i].get())
                i = i + 1

            # Copy bytes from other string
            i = 0
            while i < other_size:
                result.add(other.data[i].get())
                i = i + 1

            result.add(0)  # Null terminator
            return String{result}

        pub def contains(substr: String) -> bool:
            if substr == null:
                return false

            if substr.is_empty():
                return true

            if this.is_empty():
                return false

            const this_size = this.data/size.get() - 1
            const substr_size = substr.data/size.get() - 1

            if substr_size > this_size:
                return false

            var i: usize = 0
            while i <= this_size - substr_size:
                var matches = true
                var j: usize = 0
                while j < substr_size:
                    if this.data[i + j].get() != substr.data[j].get():
                        matches = false
                        break
                    j = j + 1

                if matches:
                    return true
                i = i + 1

            return false

        pub def starts_with(substr: String) -> bool:
            if substr == null:
                return false

            if substr.is_empty():
                return true

            if this.is_empty():
                return false

            const this_size = this.data/size.get() - 1
            const substr_size = substr.data/size.get() - 1

            if substr_size > this_size:
                return false

            var i: usize = 0
            while i < substr_size:
                if this.data[i].get() != substr.data[i].get():
                    return false
                i = i + 1

            return true

        pub def ends_with(substr: String) -> bool:
            if substr == null:
                return false

            if substr.is_empty():
                return true

            if this.is_empty():
                return false

            const this_size = this.data/size.get() - 1
            const substr_size = substr.data/size.get() - 1

            if substr_size > this_size:
                return false

            const offset = this_size - substr_size
            var i: usize = 0
            while i < substr_size:
                if this.data[offset + i].get() != substr.data[i].get():
                    return false
                i = i + 1

            return true

        pub def find(substr: String) -> usize:
            if substr == null:
                return 4294967295  # u32::MAX (not found)

            if substr.is_empty():
                return 0

            if this.is_empty():
                return 4294967295  # u32::MAX (not found)

            const this_size = this.data/size.get() - 1
            const substr_size = substr.data/size.get() - 1

            if substr_size > this_size:
                return 4294967295  # u32::MAX (not found)

            var i: usize = 0
            while i <= this_size - substr_size:
                var matches = true
                var j: usize = 0
                while j < substr_size:
                    if this.data[i + j].get() != substr.data[j].get():
                        matches = false
                        break
                    j = j + 1

                if matches:
                    return i  # Return byte index where substring starts
                i = i + 1

            return 4294967295  # u32::MAX (not found)

        pub def replace(old: String, new: String) -> String:
            if old == null or new == null:
                return this  # Cannot replace with null

            if old.is_empty():
                return this  # Cannot replace empty string

            if this.is_empty():
                return this

            const find_pos = this.find(old)
            if find_pos == 4294967295:  # u32::MAX (not found)
                return this

            # Calculate new size
            const this_size = this.data/size.get() - 1
            const old_size = old.data/size.get() - 1

            # Create result vector
            var result: Vector<u8> = Vector()

            # Copy bytes before the matches
            var i: usize = 0
            while i < find_pos:
                result.add(this.data[i].get())
                i = i + 1

            # Copy replacement string
            i = 0
            const new_data_size = new.data/size.get()  - 1
            while i < new_data_size:
                result.add(new.data[i].get())
                i = i + 1

            # Copy bytes after the matches
            i = find_pos + old_size
            while i < this_size:
                result.add(this.data[i].get())
                i = i + 1

            result.add(0)  # Null terminator
            return String{result}

        pub def is_empty() -> bool:
            return this.data/size.get() <= 1  # Only null terminator

    # character access paths
    path chars:
        pub def get() -> Vector<char>:
            var chars: Vector<char> = Vector()
            const size = this.data/size.get() - 1  # Exclude null terminator
            var i: usize = 0

            while i < size:
                const byte: u32 = this.data[i].get() as u32

                # Handle UTF-8 decoding
                if byte < 128:  # ASCII (1 byte)
                    chars.add(byte as char)
                    i = i + 1
                else if byte < 224:  # 2-byte UTF-8
                    if i + 1 < size:
                        const byte1: u32 = this.data[i + 1].get() as u32
                        const codepoint: u32 = ((byte - 192) * 64) + (byte1 - 128)
                        chars.add(codepoint as char)
                        i = i + 2
                    else:
                        i = i + 1  # Invalid UTF-8, skip
                else if byte < 240:  # 3-byte UTF-8
                    if i + 2 < size:
                        const byte1: u32 = this.data[i + 1].get() as u32
                        const byte2: u32 = this.data[i + 2].get() as u32
                        const codepoint = ((byte - 224) * 4096) + ((byte1 - 128) * 64) + (byte2 - 128)
                        chars.add(codepoint as char)
                        i = i + 3
                    else:
                        i = i + 1  # Invalid UTF-8, skip
                else:  # 4-byte UTF-8
                    if i + 3 < size:
                        const byte1: u32 = this.data[i + 1].get() as u32
                        const byte2: u32 = this.data[i + 2].get() as u32
                        const byte3: u32 = this.data[i + 3].get() as u32
                        const codepoint = ((byte - 240) * 262144) + ((byte1 - 128) * 4096) + ((byte2 - 128) * 64) + (byte3 - 128)
                        chars.add(codepoint as char)
                        i = i + 4
                    else:
                        i = i + 1  # Invalid UTF-8, skip

            return chars

    path chars/size:
        pub def get() -> usize:
            var char_count: usize = 0
            const size = this.data/size.get() - 1  # Exclude null terminator
            var i: usize = 0

            while i < size:
                const byte = this.data[i].get()

                # Count UTF-8 characters
                if byte < 128:  # ASCII (1 byte)
                    char_count = char_count + 1
                    i = i + 1
                else if byte < 224:  # 2-byte UTF-8
                    char_count = char_count + 1
                    i = i + 2
                else if byte < 240:  # 3-byte UTF-8
                    char_count = char_count + 1
                    i = i + 3
                else:  # 4-byte UTF-8
                    char_count = char_count + 1
                    i = i + 4

            return char_count

    path chars[index: usize]:
        pub def get() -> char:
            var char_index: usize = 0
            const size = this.data/size.get() - 1  # Exclude null terminator
            var i: usize = 0

            while i < size:
                if char_index == index:
                    const byte: u32 = this.data[i].get() as u32

                    # Decode UTF-8 character
                    if byte < 128:  # ASCII (1 byte)
                        return byte as char
                    else if byte < 224:  # 2-byte UTF-8
                        if i + 1 < size:
                            const byte1: u32 = this.data[i + 1].get() as u32
                            const codepoint = ((byte - 192) * 64) + (byte1 - 128)
                            return codepoint as char
                    else if byte < 240:  # 3-byte UTF-8
                        if i + 2 < size:
                            const byte1: u32 = this.data[i + 1].get() as u32
                            const byte2: u32 = this.data[i + 2].get() as u32
                            const codepoint = ((byte - 224) * 4096) + ((byte1 - 128) * 64) + (byte2 - 128)
                            return codepoint as char
                    else:  # 4-byte UTF-8
                        if i + 3 < size:
                            const byte1: u32 = this.data[i + 1].get() as u32
                            const byte2: u32 = this.data[i + 2].get() as u32
                            const byte3: u32 = this.data[i + 3].get() as u32
                            const codepoint = ((byte - 240) * 262144) + ((byte1 - 128) * 4096) + ((byte2 - 128) * 64) + (byte3 - 128)
                            return codepoint as char

                const byte = this.data[i].get()

                # Skip to next character
                if byte < 128:
                    i = i + 1
                else if byte < 224:
                    i = i + 2
                else if byte < 240:
                    i = i + 3
                else:
                    i = i + 4

                char_index = char_index + 1

            return 0 as char  # Return null character if index out of bounds

    # Byte access paths
    path bytes:
        pub def get() -> Vector<u8>:
            return this.data

    path bytes/size:
        pub def get() -> usize:
            return this.data/size.get() - 1  # Exclude null terminator

    path bytes[index: usize]:
        pub def get() -> u8:
            return this.data[index].get()

    # Substring path
    path substring:
        pub def get(start: usize, end: usize) -> String:
            const size = this.data/size.get() - 1  # Exclude null terminator

            # Bounds checking
            if start >= size or end > size or start >= end:
                return String{Vector()}  # Empty string

            var result: Vector<u8> = Vector()
            var i: usize = start

            while i < end:
                result.add(this.data[i].get())
                i = i + 1

            result.add(0)  # Null terminator
            return String{result}